import os
import numpy as np
import pickle
import rasterio as rio

from .geogrid import GeoGrid
from .stream import StreamNetwork, Stream


def load(filename):
    """Read a geospatial data"""

    with rio.open(filename) as dataset:
        data = dataset.read(1)  # DEM data only have 1 band.
        crs = dataset.crs
        transform = dataset.meta['transform']
        metadata = dataset.meta

    outdata = GeoGrid(data, crs, transform, metadata)

    return outdata


def network_to_shp(stream_network: StreamNetwork,
                   filename: str):

    stream_list = stream_network.to_streams(mode='tributary')
    stream_to_shp(stream_list, filename)


def stream_to_shp(stream, filename:str, segmented=False):
    if isinstance(stream, Stream):
        stream_list = [stream]
    else:
        stream_list = stream

    line_list = []
    attrs = {}
    for s in stream_list:
        i_list = s.dataset['rows'].data
        j_list = s.dataset['cols'].data

        x_list, y_list = s.rowcol_to_xy(i_list, j_list)

        xy_coords = np.array([[x_list[k], y_list[k]] for k in range(len(x_list))])

        if segmented:
            seg_id_list = s.dataset['segment'].data
            for seg_id in range(int(seg_id_list.max())+1):
                seg_coords = xy_coords[seg_id_list == seg_id]
                if seg_id < seg_id_list.max():
                    seg_coords = np.append(seg_coords, [xy_coords[seg_id_list == seg_id+1][0]], axis=0)
                line_list.append(seg_coords)
                if 'ksn' in attrs:
                    attrs['ksn'].append(s.dataset['ksn_segmented'].data[seg_id_list == seg_id][0])
                else:
                    attrs['ksn'] = []
                    attrs['ksn'].append(s.dataset['ksn_segmented'].data[seg_id_list == seg_id][0])
        else:
            line_list.append(xy_coords)

    import shapefile
    with shapefile.Writer(filename) as w:
        w.field('name', 'C')
        for key in attrs:
            w.field(key, 'N')
        for i in range(len(line_list)):
            w.line([line_list[i]])
            #w.record(name='Stream network generated by DEMAP')
            records_dict = {'name': 'Stream network generated by DEMAP'}
            for key in attrs:
                records_dict[key] = attrs[key][i]
            w.record(**records_dict)

def stream_to_excel(stream, filename: str):
    import pandas as pd
    if isinstance(stream, Stream):
        stream_list = [stream]
    else:
        stream_list = stream

    df_list = []
    for s in stream_list:
        df = s.dataset.to_dataframe()

        df = df.drop(['rows', 'cols'], axis=1)

        i_list = s.dataset['rows'].data
        j_list = s.dataset['cols'].data
        x_list, y_list = s.rowcol_to_xy(i_list, j_list)
        
        df.insert(0, 'Y', y_list)
        df.insert(0, 'X', x_list)
        
        df_list.append(df)

    with pd.ExcelWriter(filename) as writer:
        for k in range(len(df_list)):
            df_list[k].to_excel(writer, sheet_name='{}'.format(k+1))


def dump_pickle(res, filename):
    with open(filename, 'xb') as out_file:  # Fail if file exists.
        pickle.dump(res, out_file, pickle.HIGHEST_PROTOCOL)


def load_pickle(filename):
    with open(filename, 'rb') as in_file:
        res = pickle.load(in_file)
    return res


def save_as_tiff(grid, filename):
    import rasterio as rio

    with rio.open(
        filename,
        'w',
        driver='GTiff',
        height=grid.dataarray.shape[0],
        width=grid.dataarray.shape[1],
        count=1,
        dtype=grid.dataarray.dtype,
        crs=grid.dataarray.attrs['crs'],
        transform=grid.dataarray.attrs['transform'],
    ) as dst:
        dst.write(grid.dataarray.data, 1)
        